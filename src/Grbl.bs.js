// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Rxjs = require("rxjs");
var Process = require("process");
var JsSerial$Base = require("./JsSerial.bs.js");

function send(grbl, message) {
  return JsSerial$Base.write(grbl.serial, message);
}

function sendMany(grbl, _messages) {
  while(true) {
    var messages = _messages;
    if (messages) {
      JsSerial$Base.write(grbl.serial, messages[0]);
      _messages = messages[1];
      continue ;
    } else {
      return ;
    }
  };
}

function commandToString(command) {
  switch (command.tag | 0) {
    case /* G0 */0 :
        return "G0 " + (command[0].toString() + (" " + command[1].toString()));
    case /* G1 */1 :
        return "G1 " + (command[0].toString() + (" " + command[1].toString()));
    case /* M3 */2 :
        return "M3 S" + command[0].toString();
    
  }
}

function sendCommand(grbl, command) {
  var message = commandToString(command);
  return JsSerial$Base.write(grbl.serial, message);
}

function init(device) {
  var port = JsSerial$Base.serial(device, undefined, /* () */0);
  var readline = JsSerial$Base.readline(port);
  var read = new Rxjs.Subject();
  var write = new Rxjs.Subject();
  readline.on("data", (function (line) {
            var port$1 = port;
            var msg = line.trim();
            console.log(">", msg);
            var tmp;
            if (msg === "[MSG:'$H'|'$X' to unlock]") {
              tmp = "$X";
            } else {
              read.next(msg);
              tmp = undefined;
            }
            return JsSerial$Base.writeOption(port$1, tmp);
          })).on("close", (function (param) {
          console.log("port closed, exiting");
          return Process.exit(0);
        }));
  return {
          serial: port,
          read: read,
          write: write
        };
}

exports.send = send;
exports.sendMany = sendMany;
exports.commandToString = commandToString;
exports.sendCommand = sendCommand;
exports.init = init;
/* rxjs Not a pure module */
